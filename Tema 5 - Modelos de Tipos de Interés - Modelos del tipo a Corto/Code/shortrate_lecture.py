# -*- coding: utf-8 -*-
"""ShortRate_lecture.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YvohdVdRnyDQaSDS8wZXLx038y67429_

# **Curva a tiempo 0 y LGM Curve**
"""

import numpy as np
from scipy.interpolate import interp1d
import scipy as sc
import scipy.stats as st
import matplotlib.pyplot as plt
import inspect

plt.style.use('default')

# ------------------------------------------------

# Clase Curva
class IRCurve:
  
  # CONSTRUCTOR (Da vida a la clase)
  def __init__(self, dates, dfs):
    self._ref_date = dates[0]
    self._dfs = dfs
    self._times = (dates - dates[0]) / 365.25
    self._rates_time = -np.log(dfs)
    self._curve = interp1d(self._times, self._rates_time, kind = 'cubic')
  
  # Devuelve B(t, T) = B(0, T) / B(0, t)
  def get_zero(self, t, T):
    B_0_T = np.exp(-self._curve((T-self._ref_date)/365.25))
    B_0_t = np.exp(-self._curve((t-self._ref_date)/365.25))
    
    return B_0_T / B_0_t
  
 # -----------------------------------------------------
 
def H(kappa, time):
  return (1 - np.exp(-kappa * time)) / kappa
  
  
# Definición de la clase LGM
class LGMCurve:

  # CONSTRUCTOR
  def __init__(self, IR_curve, kappa, sigma):
    self._curve = IR_curve
    self._kappa = kappa
    self._sigma = sigma

  # Numerario: N(t, xt)
  def numeraire(self, t, xt):

    time_to_t = (t - self._curve._ref_date) / 365.25
    ht = H(self._kappa, time_to_t)
    zeta_t = (self._sigma ** 2) * time_to_t

    exponent = ht * xt + 0.5 * (ht**2) * zeta_t

    return 1 / self._curve.get_zero(self._curve._ref_date, t) \
            * np.exp(exponent)
  
  # B(t, T, xt)
  def get_zero_x(self, t, T, xt):

    time_to_t = (t - self._curve._ref_date) / 365.25
    time_to_T = (T - self._curve._ref_date) / 365.25

    ht = H(self._kappa, time_to_t)
    hT = H(self._kappa, time_to_T)

    zeta = (self._sigma * self._sigma) * time_to_t

    df = self._curve.get_zero(t, T) 
    exponent = (hT -ht ) * xt + 0.5 * (hT * hT - ht * ht) * zeta 

    df *= np.exp(-exponent)

    return df
    
    
 # -----------------------------------------------------
#%%
"""# **PRUEBA CLASE CURVA y LGM Curve**

1. Probamos la función get_zero que nos devuelve Factores de descuento vistos a Value Date
"""

today = 43533
last_date = today + 365.25 * 25

##--------------------------------ParametrosIniciales--------------------------------##
####
# Aquí defino los pillar_dates y los dfs (en realidad se habrían obtenido construyendo una curva)
####

# Defino las fechas pilar para los factores de desceunto ...
pillar_dates = np.linspace(today, last_date, 50)

# Defino los rates como curva no plana
dates_rates = np.array([today, today + 365, today + 365 * 5, today + 365 * 10, \
                       today +365 * 20, today + 365 * 30, today + 365 * 50])
rates = np.array([0.0, 0.005, 0.01, 0.015, 0.02, 0.025, 0.028])

# Calculo los FD de acuerdo a esa estructura no plana de tipos
dfs = np.zeros(len(pillar_dates))
rate_interp = interp1d(dates_rates, rates, kind = 'linear')
for i in range(len(pillar_dates)):
  rate = rate_interp(pillar_dates[i])
  dfs[i] = (np.exp(-rate * (pillar_dates[i] - today)/ 365.25))

##--------------------------------IRCurve--------------------------------##    
####
# Aquí defino la IRCurve, que me generara los factores de descuento 
####
# DEFINIMOS IRCurve (esta es la curva estatica, la original que se obtiene de mercado)    
    # dfs - son los factores de descuento a fechas pillar dates (calibración de curva a objetos de mercado)
    # pillar_dates - son las fechas de esos intrumentos de mercado
    # Por lo tanto, tendría ambos cacharros, son como parametros dados
# Definimos IR Curve (Curva original)  
ir_curve = IRCurve(pillar_dates, dfs)

##--------------------------------LGMCurve--------------------------------##    
####
# Aquí defino la LGMCurve, que me generara los factores de descuento influenciados por la X_t
####
# PROBAR FUNCIONAMIENTO DE LGMCurve
kappa = 0.01
sigma = 0.01

lgm_curve = LGMCurve(ir_curve, kappa, sigma )

##--------------------------------Pruebas--------------------------------## 
####
# Aquí pruebo que la funcion los factores de descuento que me daría el LGMCurve en t=0
####
df_lgm_at_pillar_dates = [lgm_curve.get_zero_x(today, T, 0) for T in pillar_dates]
# get_zero_x(self, t, T, xt) xt en 0 es 0 por defincion
# El modelo replica bien los dfs originales en las pillar_dates

# GENERATE GRAPH ...  
f, ax = plt.subplots()

ax.plot(pillar_dates, dfs, 'o',label = 'DF original')
ax.plot(pillar_dates, df_lgm_at_pillar_dates, 'x',label = 'DF LGM')

ax.legend()

f.set_size_inches(6, 3)

"""# **Prueba: Validar que el LGM cumple con el Teorema Fundamental de Valoración**

1. Simulamos el Factor de descuento a futuro de acuerdo al LGM y normalizamos path a path por el numerario.
2. Calculamos la media de estas realizaciones por fecha y comparamos contra el Factor de descuento hoy.
"""

T = today + 20 * 365.25
simul_dates = np.linspace(today, T, 20)

nb_of_simuls = 1000000

means = []
std_dev = []

# BUCLE SIMULACIÓN ...
for date_i in simul_dates:
  print(date_i)
  N_0_1 = np.random.normal(size = nb_of_simuls)
  zeta_i = ((date_i - today) / 365.25)  * (sigma ** 2)
  X_at_date_i =  N_0_1 * np.sqrt(zeta_i)
  
  # Obtenemos FD con LGM B(date_i, T, x_date_i)
  B_ti_T =  lgm_curve.get_zero_x(date_i, T, X_at_date_i)
  N_ti = lgm_curve.numeraire(date_i, X_at_date_i)
  
  # FACTOR de descuento normalizado por numerario
  DF_normalized = B_ti_T / N_ti
  
  # Calculamos la media ...
  mean_ti = np.mean(DF_normalized)
  means.append(mean_ti)
  
  # Calculamos intervalo de confianza ...
#  normal_percentile = sc.stats.norm.ppf(0.975)
  normal_percentile = st.norm.ppf(0.975)
  std = np.std(DF_normalized) / np.sqrt(nb_of_simuls) * normal_percentile
  std_dev.append(std)

print('Means: ', means)
  
# PRINT 

#print(inspect.getsource(lgm_curve.get_zero_x))
#print(inspect.getsource(ir_curve.get_zero))
#inspect.getmembers(LGMCurve, lambda a:not(inspect.isroutine(a)))
B0T = lgm_curve.get_zero_x(today, T, 0) # Este valor es el que devuelve la curva original, tiene X_t = 0
print('Factor de descuento entre today -> T por modelo LGM con X_t = 0 coincide con FD de la curva original \n', \
      B0T == ir_curve.get_zero(today, T))
f, ax = plt.subplots()
ax.plot(simul_dates, means, 'o', label = 'Discount Factor Normalized ...')  
ax.plot(simul_dates, B0T + np.array(std_dev), '-', label = 'Upper Confidence Interval')  
ax.plot(simul_dates, B0T - np.array(std_dev), '-', label = 'Lower Confidence Interval')

#%%
"""## **1. Valorar Caplets de acuerdo al LGM en función del strike**"""

from scipy.stats import norm

# ----------------------------------------- | ----------

# BLACK SCHOLES ..
def LN_BlackScholes(S0, K, T, sigma):
  d1 = (np.log(S0/K) + 0.5 *  (sigma**2) * T )/(np.sqrt(T) * sigma)
  d2 = d1 - sigma * np.sqrt(T)
  
  return S0 * norm.cdf(d1) - K * norm.cdf(d2) 

# ----------------------------------------- | ----------

# Tenemos curva
# Definimos IR Curve (Curva original)  
ir_curve = IRCurve(pillar_dates, dfs)

# Tenemos modelo que mueve libor (por su relación con los tipos)
# Probar funcionamiento del LGM
# Parámetros del LGM
kappa = 0.01
sigma = 0.01  # SIGMA del proceso X
lgm_curve = LGMCurve(ir_curve, kappa, sigma )

# Definimos características del caplet ..
# tj (fecha de fijación del libor).
mty_date = today + 5 * 365.25                   # t_j
# tj+1 (fecha de pago)
pymt_date = mty_date + 365                      # t_j_1
# Intervalo temporal (Delta_t)
Delta = (pymt_date - mty_date) / 360.0

# ir_curve.get_zero(mty_date) = B(t0,tj)
# 1/Delta es el Delta a la menos 1
libor_today = (ir_curve.get_zero(today, mty_date) / ir_curve.get_zero(today, pymt_date) \
               - 1)/ Delta
print('Forward libor: ', libor_today)

# Calcular el precio para varios K de acuerdo al LGM ---------

# 1. Calcular volatilidad de BS ... Vola del modelo sigma(Htj+1 - Htj)
time_to_mty_date  = (mty_date - today) / 365.25
time_to_pymt_date = (pymt_date - today) / 365.25

sigma_BS = sigma * (H(kappa, time_to_pymt_date) - \
                    H(kappa, time_to_mty_date))

print('Sigma que usamos en BS', sigma_BS)

# Definimos rango de strikes
lower_bound = -0.05
upper_bound = 0.1
number_of_strikes = 20
K = np.linspace(lower_bound, upper_bound, number_of_strikes)

# Calculamos el C(K) bajo el LGM
# Calcular premium (NPV - c(k)) bajo LGM - el desplazamiento del LN es la inversa del Delta
# Porque estamos aplicando el BS a u (que es la variable desplazada)
premium = LN_BlackScholes(libor_today + 1.0 / Delta, K + 1.0/ Delta, \
                          (mty_date - today) / 365.25, sigma_BS)

# Grafico las primas en función del strike ...
f, ax = plt.subplots()
ax.plot(K, premium, 'o', label = 'C(K)')

print('premium', premium)


# ---> Valoración de los caplets por MC

# 1. Simulamos la x hasta mty ...
# 1.- Simulamos X_t (hasta el momento t - mty) (Fecha de fixing del libor)
# dx = sigma_s * dW_s - Por lo tanto X~N(0, sigma*sigma * t) Var viene de isometria de Ito
nb_simul = 10000
x_at_mty = np.random.normal(size = nb_simul) * \
              sigma * np.sqrt(time_to_mty_date) 
# multiplicamos por sd(X) = sigma*sqrt(time_to_mty_date) - Por que la X se simula hasta la fecha fixing

# 2. Evaluamos el pay-off normalizado por el numerario
#    a vencimiento (L-K)^+ Delta

# 2.1 Libor a fecha de mty date
# Para calcular el Libor = (B(tj, tj)/B(tj, tj+1)) - 1) - B(tj, tj) = 1 - B(tj, tj+1) del objeto lgm_curve.get_zero_x
libor_at_mty_date = (1.0 / lgm_curve.get_zero_x(mty_date, pymt_date, \
                                                x_at_mty)-1)/Delta

# 2.2 Calculamos el numerario a la fecha de pago
x_at_pymt_date = x_at_mty + np.random.normal(size = nb_simul) * \
                            sigma * np.sqrt(time_to_pymt_date - time_to_mty_date)
#libor_at_mty_date = (lgm_curve.get_zero_x(mty_date, pymt_date, x_at_mty) / lgm_curve.get_zero_x(mty_date, pymt_date, x_at_mty) - 1) * (1/Delta)
 
# 2.2 Calculamos el numerario a la fecha de pago
# Trasladamos la normal condicionado a lo que tenemos en t_j - Por lo tanto el salto tiene N(X_at_mty, sigma(tj+1-tj))                           
numeraire_at_pymt_date = lgm_curve.numeraire(pymt_date, x_at_pymt_date)

# 2.3.- Iteramos para evaluar el payoff normalizado para cada strike
premium_MC = np.zeros(len(K))
for i in range(len(K)):
  
    # Evaluo payoff normalizado
  payoff_normalized = np.maximum(libor_at_mty_date - K[i], 0.0) * Delta
  payoff_normalized /= numeraire_at_pymt_date
  
  # Calculo la media
  
  mean = np.mean(payoff_normalized)
  premium_MC[i] = mean # Estos premium estan descontados hasta hoy, hay que llevarlos a t_j+1 (que es lo que hemos obtenido en BS - prima forward)


# Graficamos primas de MC para compararlas con las analíticas
# Calculamos el factor de descuento para llevar las primas_MC de 0 a t_j+1
df_at_pymt_date = ir_curve.get_zero(today, pymt_date)
ax.plot(K, premium_MC / df_at_pymt_date, 'x', label = 'MC Premium')
  
  
ax.legend()
f.set_size_inches(6, 4)

print('Premium MC', premium_MC)

# Resultados
print("Resultados con Monte Carlo \n", premium_MC)
print("Libor en maturity (fecha de fixing) - se usa para calcular el payoff (L - K) \n", libor_at_mty_date)
print("Numeraire generado por modelo LGM en t_j+1 (para normalizar)\n", numeraire_at_pymt_date)

# Plots - Graficamos primas de MC para compararlas con analiticas
ax.plot(K, premium_MC, '+', label = "MC_Premium - No capitalizadas")
ax.plot(K, premium_MC / df_at_pymt_date, '*', label = "MC_Premium - Capitalizadas")
ax.legend();

print("Numeraire at maturity - Lo utilizamos para normalizar \n", lgm_curve.numeraire(pymt_date, x_at_mty))

print("B(tj, tj) = 1  del objeto lgm_curve.get_zero_x \n", (lgm_curve.get_zero_x(pymt_date, pymt_date, x_at_mty)))

print("B(tj, tj+1) del objeto lgm_curve.get_zero_x \n", (lgm_curve.get_zero_x(mty_date, pymt_date, x_at_mty)))

#%%
"""**Calculamos la función de densidad del libor a partir de precios de Caplets**"""
# Calculo de función de densidad del subyacente (libor) a partir del precio de los caplets - Derivando dos veces con respecto al strike*
# Vamos a calcular por diferencias finitas, necesitamos que haya muchos puntos donde calcular, para reducir el error
lower_bound = -0.25
upper_bound = 0.25
K = np.linspace(lower_bound, upper_bound, 100)

# Calculamos el C(K) bajo el LGM
# Valoraremos el Caplet (c(K)) utilizando BS - Es decir, bajo LGM
premium = LN_BlackScholes(libor_today + 1.0 / Delta, K + 1.0/ Delta, \
                          (mty_date - today) / 365.25, sigma_BS)

dK = K[1] - K[0] # Asume que K[i+1]-K[i] es igual para todo i

# 1.- Función de distribución
# Calculamos la derivada dC(K)dK = [C(K + dK) - C(k)] / dK -> Derivada forward
der_right = (premium[1:]-premium[0:-1]) / dK # K - cada punto de premium, pero si yo hago K+dK sería el siguiente punto 
# (premium[2] - premium[1])/dK - esto sería la derivada en el primer punto K+dK es premium[2] - 


f, ax = plt.subplots()
# Es decreciente por que el perfil anterior tiene derivada negativa - baja
#ax.plot(K[0:-1], der_right, 'o', label = "dC(K)/dK - Es como una función de distribución")
# Le cambiamos el signo para que sea funcion de distribución real - Prob acumulada hasta cada punto, prob de que S_t > K
ax.plot(K[0:-1], -der_right, 'o', label = 'dC(K)/dK - Func Distr Acu del suby')

# Print
print("Premium \n", premium[0:10])
print("Derivada Derecha \n", der_right[0:10])

# Función de densidad

# Derivada segunda d2C(K)/dK2 = [C(K - dK) + 2C(K) + C(K + dK)] / dK^2
second_der = (premium[0:-2] - 2 * premium[1:-1] + premium[2:]) / (dK*dK) # La segunda derivad descarta dos elementos
ax.plot(K[0:-2], second_der, '-', label = 'Density function')

#%%
### **Calculo del Smile de volatilidad**
"""
Invertimos las primas del caplet para sacarnos el smile de Volatilidad
La volatilidad de Black - que hace consistente Black con LGM no va a ser siempre estable
Black asume dinamica estable

Vol de ambos modelos son distintos
"""

from scipy import optimize

# Hay que hacer un solver para invertir la formula de BS
lower_bound = 0.03 # Requiere strike positivo
upper_bound = 0.1
K = np.linspace(lower_bound, upper_bound, 20)

# Calculamos el C(K) bajo el LGM
# Valoraremos el Caplet (c(K)) utilizando BS - Es decir, bajo LGM
# Aqui hemos desplazado u(t) el libor y la k
premium = LN_BlackScholes(libor_today + 1.0 / Delta, K + 1.0/ Delta, \
                          (mty_date - today) / 365.25, sigma_BS)

# Nuestro objetivo va a ser calcular el sigma x - precio con BS - precio al que nos queremos parecer
implicit_vols = np.zeros(len(K))
for i in range(len(K)):
  
  premium_lgm = premium[i]
    # Aquí no desplazamos nada, aplicamos BS tal cual a nuestro (Libor - K)
    # Es decir, en este caso, meto en el BS los valores sin ajustar y recupero las volatilidades que tendria
    # que incluir en el model BS para recuperar las primas
    # Es decir, cojo la vol que obtengo, la meto en el BS sin desplazar ni libor ni k y obtengo la prima que obtendria
    # habiendo calculado con los desplazados
  
  f_obj = lambda vol_BS : LN_BlackScholes(libor_today , K[i] , \
                                          (mty_date - today) / 365.25, vol_BS) - premium_lgm
  
  implicit_vols[i] = optimize.newton(f_obj, .25)
  
# Graficamos el smile de volatilidad
f, ax = plt.subplots()
ax.plot(K, implicit_vols, 'o', label = 'Smile de volatilidad (LGM)')

# Resultados
print("Vol implicita - necesaria para recuperar precios usando BS \n", implicit_vols)  
print(implicit_vols)
  
print("Modelo LGM - Desplazando libor y strike \n", LN_BlackScholes(libor_today + 1/Delta, K[0] + 1/Delta, (mty_date - today)/365.25, sigma_BS))

print("Modelo BS - sin desplazar ni Libor ni strike, y con vola de modelo LGM (sigma_BS) \n", LN_BlackScholes(libor_today, K[0], (mty_date - today)/365.25, sigma_BS))
print("Lo anterior es erroneo!!!! Por que la volatilidad no es la correcta")
print("Modelo BS - sin desplazar ni Libor ni strike, y con vola de modelo implicita \n", LN_BlackScholes(libor_today, K[0], (mty_date - today)/365.25, implicit_vols[0]))

print("1 y 3 coinciden!!! Esto indica que si yo recupero mis volas implicitas y las aplico al modelo BS recupero los precios")
print("Lo que hago es recuperar el precio usando la vol implicita (sigma(k1)*) tal que BS_LN[S0, k1, T, sigma(k1)*] = C(K1)_enLGM")

# Hay que hacer un solver para invertir la formula de BS

lower_bound = 0.01 # Requiere strike positivo
upper_bound = 0.15
K = np.linspace(lower_bound, upper_bound, 20)

# Valoraremos el Caplet (c(K)) utilizando BS - Es decir, bajo LGM
# Aqui hemos desplazado u(t) el libor y la k
premium = LN_BlackScholes(libor_today + 1/Delta, K + 1/Delta, \
                          (mty_date - today)/365.25, sigma_BS)

# Nuestro objetivo va a ser calcular el sigma x - precio con BS - precio al que nos queremos parecer
implicit_vols = np.zeros(len(K))
for i in range(len(K)):
    
    premium_lgm = premium[i]
    # Aquí no desplazamos nada, aplicamos BS tal cual a nuestro (Libor - K)
    # Es decir, en este caso, meto en el BS los valores sin ajustar y recupero las volatilidades que tendria
    # que incluir en el model BS para recuperar las primas
    # Es decir, cojo la vol que obtengo, la meto en el BS sin desplazar ni libor ni k y obtengo la prima que obtendria
    # habiendo calculado con los desplazados
    f_obj = lambda vol_BS: LN_BlackScholes(libor_today + 1/Delta, K[i] + 1/Delta, \
                                           (mty_date - today)/365.25, vol_BS) - premium_lgm  # Función para la cual buscamos el cero
    
    implicit_vols[i] = solution = sc.optimize.newton(f_obj, 0.2) # Esto devuelve la raiz (ojo con la condicion inicial)

# Plot del smile de vola
f, ax = plt.subplots()

ax.plot(K, implicit_vols, 'o', label = 'LGM smile vola')
ax.legend();

print("Vol implicita - necesaria para recuperar precios usando BS \n", implicit_vols)
# Como hemos corregido el el modelo, desplazandolo, las Vol implicitas son iguales a la vol del LGM
print("Vol de modelo LGM \n", sigma * (H(kappa, time_to_pymt_date) - H(kappa, time_to_mty_date)))

#%%
# Valorar IRS de acuerdo a LGM

"""![texto alternativo](https://docs.google.com/a/bbva.com/drawings/d/e/2PACX-1vRbaWl-u8mzZt3u8xsCl-f6GKaTMlz_wBIR4Qft036A-OzLeFHtNboK3arMQfaDb7wSQ_C1dbOxi_1I/pub?w=960&h=720)

1. Creamos clase de definición IRS
2. Función que valora el IRS de acuerdo a LGM
"""

today = 43547 # 23/3/2019
last_date = today + 365.25 * 25

# Defino las fechas pilar para los factores de desceunto ...
pillar_dates = np.linspace(today, last_date, 50)

# Defino los rates como curva no plana
dates_rates = np.array([today, today + 365, today + 365 * 5, today + 365 * 10, \
                       today +365 * 20, today + 365 * 30, today + 365 * 50])
rates = np.array([0.0, 0.005, 0.01, 0.015, 0.02, 0.025, 0.028])

# Calculo los FD de acuerdo a esa estructura no plana de tipos
dfs = np.zeros(len(pillar_dates))
rate_interp = interp1d(dates_rates, rates, kind = 'linear')
for i in range( len(pillar_dates)):
  rate = rate_interp(pillar_dates[i])
  dfs[i] = (np.exp(-rate * (pillar_dates[i] - today)/ 365.25))

# Definimos IR Curve (Curva original)  
ir_curve = IRCurve(pillar_dates, dfs)

# Probar funcionamiento del LGM
kappa = 0.01
sigma = 0.01
lgm_curve = LGMCurve(ir_curve, kappa, sigma )

# CLASE IRS
class IRS:
  
  def __init__(self, start_date, tenor, freq, fixed_coupon):
    self.start_date = start_date
    self.end_date = start_date + tenor * 365.25
    self.fix_dates = np.linspace(self.start_date, self.end_date, tenor * freq) 
    self.fixed_coupon = fixed_coupon
    self.dcf = (self.fix_dates[1:] - self.fix_dates[0:-1])/360 # Act/360
    self.fix_dates = self.fix_dates[1:]


    
# Función que valora el IRS de acuerdo al LGM
def LGM_IRS_price(value_date, irs, lgm_curve, x_at_value_date):
  
  # Pata Flotante
  floating_leg = lgm_curve.get_zero_x(value_date, irs.start_date, x_at_value_date) - \
                 lgm_curve.get_zero_x(value_date, irs.end_date, x_at_value_date) 
    
  # Pata Fija
  fixed_leg = 0
  for i in range(len(irs.fix_dates)):
    fixed_leg += irs.dcf[i] * lgm_curve.get_zero_x(value_date, \
                                                   irs.fix_dates[i], x_at_value_date)
  
  fixed_leg *= irs.fixed_coupon
  
  return (floating_leg - fixed_leg)


# Función de valoración del swaption
def LGM_Swaption_Price(value_date, irs, lgm_curve):
  
  # 1. Calculamos x_star tal que IRS(T, x_star) = 0 
  T_mat = irs.start_date
  f_obj = lambda x : LGM_IRS_price(T_mat, irs, lgm_curve, x)
  x_star = optimize.newton(f_obj, 0)
  
  # Función anidada que calcula la put sobre ZC -------------
  def ZC_put(T_j):
    # Valoramos la última put sobre ZC
    fwd = lgm_curve.get_zero_x(value_date, T_j, 0) / \
          lgm_curve.get_zero_x(value_date, irs.start_date, 0)

    # strike B(T, T_N, x_star)
    strike = lgm_curve.get_zero_x(irs.start_date, T_j, x_star)

    # vol = (H_T - H_T_N) sigma_x
    vol = H(lgm_curve._kappa, (irs.start_date - value_date) / 365.25) - \
          H(lgm_curve._kappa, (T_j - value_date) / 365.25)
    
    vol *= lgm_curve._sigma
    
    vol = np.abs(vol)

    # Llamamos BS
    last_call = LN_BlackScholes(fwd, strike, \
                               (irs.start_date - value_date)/365.25, vol)
    last_put = last_call - (fwd - strike)
    
    return last_put
  # ------------------------------------------------------------
  
  # Iteramos por todas las fechas de pago del IRS y calculamos \
  # las puts sobre los ZC.
  
  swaption = 0 
  for i in range(len(irs.fix_dates)):
    # Calculate put
    put = ZC_put(irs.fix_dates[i])
    
    # Calculate K Delta o (1 + K Delta)
    notional = irs.dcf[i] * irs.fixed_coupon 
    if i == len(irs.fix_dates)-1:
      notional += 1 
      
      
    # Actualizamos el precio del swaption
    swaption += notional * put
  
  return swaption
  
  
# ---------------------------------------------------------------
  
# prueba de la clase
T = today + 365.25 * 10
irs = IRS(T, 15, 2, 0.0246)

# Probamos la clase pricer de swaption
swaption_premium = LGM_Swaption_Price(today, irs, lgm_curve)

print('Analytical Swaption premium', swaption_premium)


# CUADRE POR SIMULACIÓN MC ....
x_at_T = np.random.normal(size = 100000) * lgm_curve._sigma * \
            np.sqrt((T - today) / 365.25)

irs_at_T = LGM_IRS_price(T, irs, lgm_curve, x_at_T)
irs_at_T /= lgm_curve.numeraire(T, x_at_T)
irs_at_T = np.maximum(irs_at_T, 0)


#plt.plot(x_at_T, irs_at_T, 'o')
# REVIEW
premium_MC = np.mean(np.maximum(irs_at_T,0))/ ir_curve.get_zero(today, T) 
premium_MC = np.mean(irs_at_T) / ir_curve.get_zero(today, T) 

print('Swaption premium MC', premium_MC)
print(premium_MC / swaption_premium)

####
'''
NO ESTOY SEGURO DE QUE SIRVA PARA NADA
'''
#H(lgm_curve._kappa, (irs.fix_dates[0] - today) / 365.25)
#plt.plot(np.linspace(-100,100,100),H(0.01,np.linspace(-100,100,100)),'o')
#lgm_curve = LGMCurve(ir_curve, kappa, sigma )
#  # Pata Flotante
#floating_leg = lgm_curve.get_zero_x(today, irs.start_date, 0) - lgm_curve.get_zero_x(today, irs.end_date, 0) 
#
#  # Pata Fija
#  fixed_leg = 0
#  for i in range(len(irs.fix_dates)):
#      fixed_leg += irs.dcf[i] * lgm_curve.get_zero_x(today, \
#                                           irs.fix_dates[i], 0)
#  
#      fixed_leg 
#      
#      floating_leg / fixed_leg
#      lgm_curve._sigma

#%%
"""# **Valoración del Swaption por Integral Numérica**

$swaption = E^{\mathbb{N}}_{t} [\dfrac{IRS(T,X_{T})^{+}}{N(T,X_{T})}] = \displaystyle \int_{-\infty}^{\infty }\dfrac{IRS(T,X_{T})^{+}}{N(T,X_{T})} \eta_{X_{T}|X_{0}}(x)d(x)$

$\eta_{X_{T}|X_{0}}$ Es la función de densidad

En este caso la funcion de densidad es una N(0,$ \sigma\sqrt{\Delta T}$)

Por que tenemos:

$dX_{t} = \sigma dW_{t}^{\mathbb{N}}$ subject to $X_{0} = 0$ \\
$X_{t} = X_{0} + \displaystyle \int_{o}^{T}\sigma dW_{s}$

Y sabemos que $ \displaystyle \int_{o}^{T} dW_{s}$ sigue $N(0, \sqrt{T-0}) $

Por lo tanto $E[X_{t}] = E[ X_{0} + \displaystyle \int_{o}^{T}\sigma dW_{s}]$

$E[ X_{0}] = 0$

$E[\displaystyle \int_{o}^{T}\sigma dW_{s}] = 0$


$Var( X_{0}) = 0$

$Var(\displaystyle \int_{o}^{T}\sigma dW_{s}) = \Delta T$
"""

from scipy.stats import norm
import scipy.integrate as integrate

# Función que devuelve IRS^{+}(T, X)/N(T, X)f(x) dinde f(x) es la func de dens.
def swaption_integrand(x):
  
    # Evaluamos payoff
    # Calculo valor IRS
    irs_at_T = LGM_IRS_price(T, irs, lgm_curve, x)
    # Divide por el numerario - nORMALIZA POR el numerario
    irs_at_T /= lgm_curve.numeraire(T, x)
    # Busca el maximo
    irs_at_T = np.maximum(irs_at_T, 0)

    # Evaluamos funcion de densidad
    sigma_x =  lgm_curve._sigma * np.sqrt((T-today)/365.25)
    #print('Sigma x:', sigma_x)
    #print('IRS:', irs_at_T)

    #pdf = np.exp(-(x / sigma_x)**2/2)/np.sqrt(2*np.pi) / sigma_x
    pdf = norm.pdf(x, loc=0, scale=sigma_x) 
    #print('pdf', pdf)
    return irs_at_T * pdf

f_obj = lambda x : LGM_IRS_price(T, irs, lgm_curve, x)
x_star = optimize.newton(f_obj, 0)
  
# Resolvemos el valor del swaption, resolviendo la integral ..
# Los limites de integracion serian 4*sigma_x
premium_integral = integrate.quad(swaption_integrand, x_star, 0.5)
print('ratio', premium_integral[0] / swaption_premium)
# premium_integral es una prima forward, hay que dividir por el factor de descuento
premium_integral = premium_integral[0] / ir_curve.get_zero(today, T)

print('premium_integral', premium_integral)


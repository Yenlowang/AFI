# -*- coding: utf-8 -*-
"""Notebook_Ejercicio_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IO6t910nvnDYpHjP-7sLKKpa5JpK0tIm

# Ejercicio 2

## Importar librerias
"""

import numpy as np
import matplotlib.pyplot as plt

plt.style.use('default')

from scipy.stats import norm

N = norm.cdf

from scipy.optimize import fsolve
from scipy import optimize

from plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot
import plotly.graph_objs as go
init_notebook_mode(connected=True)


def enable_plotly_in_cell():
  import IPython
  from plotly.offline import init_notebook_mode
  display(IPython.core.display.HTML('''<script src="/static/components/requirejs/require.js"></script>'''))
  init_notebook_mode(connected=False)

"""Función gráfico 3D"""

def plot_3D(data):

  enable_plotly_in_cell()


  data = [
      go.Surface(
          z=data.T
      )
  ]
  layout = go.Layout(
      title='Option price Backward',
      autosize=False,
      width=500,
      height=500,
      margin=dict(
          l=65,
          r=50,
          b=65,
          t=90
      )
  )
  fig = go.Figure(data=data, layout=layout)
  iplot(fig, filename='elevations-3d-surface')

"""Función que calcula la matriz para la resolución de la PDE Forward (Esquema Implícito)"""

def compute_M_matrix(time_grid, x_grid, time_grid_index, drift_functor, var_functor, disc_functor):
  
  M = np.zeros((len(x_grid)-2, len(x_grid)-2))
  inv_delta_x = 1/(x_grid[1]-x_grid[0])
  inv_delta_x_squared = inv_delta_x * inv_delta_x 
  
  delta_t = time_grid[1]-time_grid[0]
  
  rho = delta_t * inv_delta_x
  alpha = delta_t *  inv_delta_x_squared
  
  t = time_grid[time_grid_index]
  
  for i in range(len(x_grid)-2):
    
    x = x_grid[i+1]
    
    var = var_functor(t, x)
    drift =  drift_functor(t, x)
    disc = disc_functor(t, x)
    
    if i == 0: # equivale a j=1 en la memoria
      
      M[i,i] = 1 + delta_t * disc - rho * drift      
      M[i,i+1] = rho * drift  


    elif i == len(x_grid)-3:  # equivale a j=m-1 en la memoria

      M[i,i] = 1 + delta_t * disc + rho * drift
      M[i,i-1] = - rho * drift
      
    else:  # equivale a 1<j<m-1 en la memoria
    
      M[i,i] = 1 - 2 * alpha * var + delta_t * disc
      M[i,i+1] = alpha * var + rho/2 * drift
      M[i,i-1] = alpha * var - rho/2 * drift
      
  return M

"""## 1. PDE Forward

## Datos
"""

TTM = 0.5 #6 meses # representa último vencimiento

beta = 0.7

Spot = 9

K_min = 0
K_max = 4 * Spot
rate = 0.01
vol = 50/100

n_time = 100
n_strike = 100

drift_ftor = lambda t, x: rate*x
var_ftor = lambda t, x: -1/2*vol*vol*x**(2*beta)
disc = lambda t, x : -rate

def Forward_PDE(Spot, TTM, n_time, K_min, K_max, n_strike, sigma, drift_ftor, var_ftor, disc):
  
  time_grid = np.linspace(0,TTM, n_time + 1, True)
  strike_grid = np.linspace(K_min, K_max, n_strike + 1, True)
  option = np.zeros((n_strike + 1, n_time + 1))
  option[:,0] = np.maximum(Spot-strike_grid,0)
  
  delta_T = TTM/n_time
  
  for i in range(0,n_time):
  
    M_i = compute_M_matrix(time_grid, strike_grid, i, 
                           drift_ftor, var_ftor, disc)
    
    M_inv = np.linalg.inv(M_i)

    option[1:n_strike, i+1] = np.matmul(M_inv, option[1:n_strike,i])

    # Cond. Neumann
    option[0, i+1] = 2* option[1, i+1] - option[2, i+1]
    option[n_strike, i+1] = 2* option[n_strike-1, i+1] - option[n_strike-2, i+1]
  
  return option

option=Forward_PDE(Spot, TTM, n_time, K_min, K_max, n_strike, vol, drift_ftor, var_ftor, disc)

plot_3D(option)

"""## 2. PDE Backward"""

TTM = 0.5 

beta = 0.7

#Spot = 9
Strike = 8

S_min = 0
S_max = 4*Spot
rate = 0.01
vol = 50/100

n_time = 100
n_spot = 50

drift_ftor = lambda t, x: rate*x
var_ftor_back = lambda t, x: 1/2*vol*vol*x**(2*beta)
disc_ftor = lambda t, x : -rate

"""Función que calcula la matriz para la resolución de la PDE Backward (Esquema Implícito)"""

def compute_M_matrix_back(time_grid, x_grid, time_grid_index, drift_functor, var_functor, disc_functor):
  
  M = np.zeros((len(x_grid)-2, len(x_grid)-2))
  inv_delta_x = 1/(x_grid[1]-x_grid[0])
  inv_delta_x_squared = inv_delta_x * inv_delta_x 
  
  delta_t = time_grid[1]-time_grid[0]
  
  rho = delta_t * inv_delta_x
  alpha = delta_t *  inv_delta_x_squared
  
  t = time_grid[time_grid_index]
  
  for i in range(len(x_grid)-2):
    
    x = x_grid[i+1]
    
    var = var_functor(t, x)
    drift =  drift_functor(t, x)
    disc = disc_functor(t, x)
    
    if i == 0: # equivale a j=1 en la memoria
      
      M[i,i] = 1 - delta_t * disc + rho * drift      
      M[i,i+1] = -rho * drift  

    elif i == len(x_grid)-3:  # equivale a j=m-1 en la memoria

      M[i,i] = 1 - delta_t * disc - rho * drift
      M[i,i-1] = + rho * drift
      
    else:  # equivale a 1<j<m-1 en la memoria
    
      M[i,i] = 1 + 2 * alpha * var - delta_t * disc
      M[i,i+1] = -alpha * var - rho/2 * drift
      M[i,i-1] = -alpha * var + rho/2 * drift
      
  return M

time_grid = np.linspace(0,TTM, n_time + 1, True)
x_grid = np.linspace(S_min, S_max, n_spot + 1, True)
compute_M_matrix_back(time_grid, x_grid, 10, drift_ftor, var_ftor_back, disc_ftor)

def Backward_PDE(Strike, TTM, n_time, S_min, S_max, n_spot, sigma, drift_ftor, var_ftor_back, disc_ftor):
  
  time_grid = np.linspace(0,TTM, n_time + 1, True)
  spot_grid = np.linspace(S_min, S_max, n_spot + 1, True)

  option = np.zeros((n_spot + 1,n_time + 1))

  option[:,-1] = np.maximum(spot_grid - Strike, 0)
  
  delta_T = TTM/n_time
  
  for i in range(n_time-1,-1,-1):
  
    M_i = compute_M_matrix_back(time_grid, spot_grid, i, 
                           drift_ftor, var_ftor_back, disc_ftor)
 
    
    M_inv = np.linalg.inv(M_i)

    option[1:n_spot, i] = np.matmul(M_inv, option[1:n_spot,i+1])

    option[0, i] = 2* option[1, i] - option[2, i]
    option[n_spot, i] = 2* option[n_spot-1, i] - option[n_spot-2, i]
  
  return option

option_backward = Backward_PDE(Strike, TTM, n_time, S_min, S_max, n_spot, vol, drift_ftor, var_ftor_back, disc_ftor)

plot_3D(option_backward)

"""## 3. Comprobar el resultado para el último vencimiento implementando un esquema de diferencias finitas implícito en la ecuación backward."""

# Seleccionamos diferentes Strikes y hallamaos la c en vencimiento

K_min = 0
K_max = 4*Spot

TTM = 0.5 #6 meses # representa último vencimiento
beta = 0.7
Spot = 9
rate = 0.01
vol = 50/100

n_time = 500
n_strike = 500

drift_ftor = lambda t, k: rate*k
var_ftor = lambda t, k: -1/2*vol*vol*k**(2*beta)
disc = lambda t, k : -rate

var_ftor_back = lambda t, s: 1/2*vol*vol*s**(2*beta)

strike_grid = np.linspace(K_min, K_max, n_strike + 1, True)


K1 = strike_grid[30]
K2 = strike_grid[60]
K3 = strike_grid[80]


print('Strikes: ', [K1, K2, K3])


# Obtenemos las primas para esos strikes en vencimiento:
c = Forward_PDE(Spot, TTM, n_time, K_min, K_max, n_strike, vol, drift_ftor, var_ftor, disc)

c1 = c[30,-1]
c2 = c[60,-1]
c3 = c[80,-1]

print('c: ', [c1, c2, c3])

S_min = 0
S_max = 4*Spot

n_spot = 500
spot_grid = np.linspace(S_min, S_max, n_spot + 1, True)

# Veamos en que punto del mallado se encuentra S0
pos_S0 = np.argmin(np.abs(Spot-spot_grid))

spot_grid[pos_S0]

print('Posiciones en el mallado de S: ', [pos_S0])

# Para K1
c_Back = Backward_PDE(K1, TTM, n_time, S_min, S_max, n_spot, vol, drift_ftor, var_ftor_back, disc)
c_back_1 = c_Back[pos_S0,0]
c_back_1

# Para K2
c_Back = Backward_PDE(K2, TTM, n_time, S_min, S_max, n_spot, vol, drift_ftor, var_ftor_back, disc)
c_back_2 = c_Back[pos_S0,0]
c_back_2

# Para K3
c_Back = Backward_PDE(K3, TTM, n_time, S_min, S_max, n_spot, vol, drift_ftor, var_ftor_back, disc)
c_back_3 = c_Back[pos_S0,0]
c_back_3

"""## 4. Smile de Volatilidad"""

# Datos
Spot = 9
rate = 0.01
vol = 50/100

n_time = 100
n_strike = 100

K_min = 3
K_max = 4*Spot
strike_grid = np.linspace(K_min, K_max, n_strike + 1, True)

drift_ftor = lambda t, k: rate*k
var_ftor = lambda t, k: -1/2*vol*vol*k**(2*beta)
disc = lambda t, k : -rate

# Función Back-Scholes
def LN_BlackScholes(S0, K, T, sigma):
  d1 = (np.log(S0/K) + 0.5 *  (sigma**2) * T )/(np.sqrt(T) * sigma)
  d2 = d1 - sigma * np.sqrt(T)
  
  return S0 * norm.cdf(d1) - K * norm.cdf(d2)

"""La siguiente opción nos devuelve la volatilidad implicita para los distintos strikes que genera el modelo en los vencimientos."""

# Los parámetros de entrada son: 
# - option_TTM: valor de la opción en vencimiento.
# - Spot.
# - TTM.
# - inicio: es el punto inicial en el que el fsolve empieza a buscar la solución.

def smile(option_TTM, Spot, strike_grid, TTM, inicio):
    implicit_vols = np.zeros(len(option_TTM))

    for i in range(0, len(option_TTM)):   
        c_Forward = option_TTM[i]
        f_objetivo = lambda sigma: LN_BlackScholes(Spot, strike_grid[i], TTM, sigma) - c_Forward
        implicit_vols[i] = fsolve( f_objetivo, inicio)
    
    return implicit_vols

"""### 4.1 Vencimiento: 1 mes   ($\beta = 0.7, 0.8, 0.9)$"""

# a) Vencimiento: 1 mes
TTM = 1/12


# a.1) beta = 0.7
beta = 0.7
var_ftor = lambda t, k: -1/2*vol*vol*k**(2*beta)

option = Forward_PDE(Spot, TTM, n_time, K_min, K_max, n_strike, vol, drift_ftor, var_ftor, disc)
option_TTM = option[:,-1]

inicio = 0.5
implicit_vols_07 = smile(option_TTM, Spot, strike_grid, TTM, inicio)


# a.2) beta = 0.8
beta = 0.8
var_ftor = lambda t, k: -1/2*vol*vol*k**(2*beta)

option = Forward_PDE(Spot, TTM, n_time, K_min, K_max, n_strike, vol, drift_ftor, var_ftor, disc)
option_TTM = option[:,-1]

inicio = 0.5
implicit_vols_08 = smile(option_TTM, Spot, strike_grid, TTM, inicio)


# a.3) beta = 0.9
beta = 0.9
var_ftor = lambda t, k: -1/2*vol*vol*k**(2*beta)

option = Forward_PDE(Spot, TTM, n_time, K_min, K_max, n_strike, vol, drift_ftor, var_ftor, disc)
option_TTM = option[:,-1]

inicio = 0.5
implicit_vols_09 = smile(option_TTM, Spot, strike_grid, TTM, inicio)

# Gráfica
f, ax =plt.subplots()
ax.plot(strike_grid[10:-5], implicit_vols_07[10:-5], '.', label = 'Vol. implícita (beta = 0.7)')
ax.plot(strike_grid[10:-5], implicit_vols_08[10:-5], '.', label = 'Vol. implícita (beta = 0.8)')
ax.plot(strike_grid[10:-5], implicit_vols_09[10:-5], '.', label = 'Vol. implícita (beta = 0.9)')
ax.set_title('Smile de Volatilidad (TTM = 1 mes)')
ax.legend();
#plt.savefig("TTM1.png",  bbox_inches = 'tight', dpi= 'figure')


strike_grid[9:]

"""### 4.2 Vencimiento: 3 meses   ($\beta = 0.7, 0.8, 0.9)$"""

# b) Vencimiento: 3 meses
TTM = 3/12


# b.1) beta = 0.7
beta = 0.7
var_ftor = lambda t, k: -1/2*vol*vol*k**(2*beta)

option = Forward_PDE(Spot, TTM, n_time, K_min, K_max, n_strike, vol, drift_ftor, var_ftor, disc)
option_TTM = option[:,-1]

inicio = 0.5
implicit_vols_07 = smile(option_TTM, Spot, strike_grid, TTM, inicio)


# b.2) beta = 0.8
beta = 0.8
var_ftor = lambda t, k: -1/2*vol*vol*k**(2*beta)

option = Forward_PDE(Spot, TTM, n_time, K_min, K_max, n_strike, vol, drift_ftor, var_ftor, disc)
option_TTM = option[:,-1]

inicio = 0.5
implicit_vols_08 = smile(option_TTM, Spot, strike_grid, TTM, inicio)


# b.2) beta = 0.9
beta = 0.9
var_ftor = lambda t, k: -1/2*vol*vol*k**(2*beta)

option = Forward_PDE(Spot, TTM, n_time, K_min, K_max, n_strike, vol, drift_ftor, var_ftor, disc)
option_TTM = option[:,-1]

inicio = 0.4
implicit_vols_09 = smile(option_TTM, Spot, strike_grid, TTM, inicio)


# Gráfica
f, ax =plt.subplots()
ax.plot(strike_grid[5:-5], implicit_vols_07[5:-5], '.', label = 'Vol. implícita (beta = 0.7)')
ax.plot(strike_grid[5:-5], implicit_vols_08[5:-5], '.', label = 'Vol. implícita (beta = 0.8)')
ax.plot(strike_grid[5:-5], implicit_vols_09[5:-5], '.', label = 'Vol. implícita (beta = 0.9)')
ax.set_title('Smile de Volatilidad (TTM = 3 meses)')
ax.legend();
#plt.savefig("TTM3.png",  bbox_inches = 'tight', dpi= 'figure')
"""### 4.3 Vencimiento: 6 meses   ($\beta = 0.7, 0.8, 0.9)$"""

# a) Vencimiento: 6 meses
TTM = 6/12


# b.1) beta = 0.7
beta = 0.7
var_ftor = lambda t, k: -1/2*vol*vol*k**(2*beta)

option = Forward_PDE(Spot, TTM, n_time, K_min, K_max, n_strike, vol, drift_ftor, var_ftor, disc)
option_TTM = option[:,-1]

inicio = 0.5
implicit_vols_07 = smile(option_TTM, Spot, strike_grid, TTM, inicio)


# b.2) beta = 0.8
beta = 0.8
var_ftor = lambda t, k: -1/2*vol*vol*k**(2*beta)

option = Forward_PDE(Spot, TTM, n_time, K_min, K_max, n_strike, vol, drift_ftor, var_ftor, disc)
option_TTM = option[:,-1]

inicio = 0.5
implicit_vols_08 = smile(option_TTM, Spot, strike_grid, TTM, inicio)


# b.2) beta = 0.9
beta = 0.9
var_ftor = lambda t, k: -1/2*vol*vol*k**(2*beta)

option = Forward_PDE(Spot, TTM, n_time, K_min, K_max, n_strike, vol, drift_ftor, var_ftor, disc)
option_TTM = option[:,-1]

inicio = 0.4
implicit_vols_09 = smile(option_TTM, Spot, strike_grid, TTM, inicio)


# Gráfica
f, ax =plt.subplots()
ax.plot(strike_grid[5:-5], implicit_vols_07[5:-5], '.', label = 'Vol. implícita (beta = 0.7)')
ax.plot(strike_grid[5:-5], implicit_vols_08[5:-5], '.', label = 'Vol. implícita (beta = 0.8)')
ax.plot(strike_grid[5:-5], implicit_vols_09[5:-5], '.', label = 'Vol. implícita (beta = 0.9)')

ax.set_title('Smile de Volatilidad (TTM = 6 meses)')
ax.legend();
#plt.savefig("TTM6.png",  bbox_inches = 'tight', dpi= 'figure')

# -*- coding: utf-8 -*-
"""SABR_Functions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sL3tAnZgx0rrX-4hOBPK7dqQGqZ2JqM3
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from scipy.stats import norm
from scipy import optimize
from collections import namedtuple

import scipy as scp


# EVALUATE BS ..
def BS_norm_price(F, K, T, vol):
  sigma_sqrt_t = vol * np.sqrt(T)
  d1 = (F - K) / sigma_sqrt_t
  
  return (F-K) * norm.cdf(d1) + sigma_sqrt_t * norm.pdf(d1)
# ----------------------------------------------



# LOGNORMAL PRICE ...
def BS_LogNorm_price(F, K, T, vol):
  sigma_sqrt_t = vol * np.sqrt(T)
  d1 = (np.log(F/K) + 0.5 * (sigma_sqrt_t ** 2))/sigma_sqrt_t
  d2 = d1 - sigma_sqrt_t
  
  return F * norm.cdf(d1) - K * norm.cdf(d2)
# ----------------------------------------------



# LN BS VEGA..
def BS_LN_vega(F, K, T, vol):
  sigma_sqrt_t = vol * np.sqrt(T)
  d1 = (np.log(F/K) + 0.5 * (sigma_sqrt_t ** 2))/sigma_sqrt_t
  
  return F * np.sqrt(T) * norm.pdf(d1)
# ----------------------------------------------



# Normal BS VEGA..
def BS_norm_vega(F, K, T, vol):
  sigma_sqrt_t = vol * np.sqrt(T)
  d1 = (F - K) / sigma_sqrt_t
  
  return np.sqrt(T) * norm.pdf(d1)
# ----------------------------------------------


# FROM NORMAL TO LOGNORMAL VOL ...
def from_normal_to_lognormal_vol(F, K, T, normal_vol, d = 0):
  
  premium = BS_norm_price(F, K, T, normal_vol)
  
  foo = lambda vol : BS_LogNorm_price(F + d, K + d, T, vol) - premium
  
  root = optimize.newton(foo, normal_vol/ (F + d) )

  return root 
## ------------------------------------------------


# FROM LOG-NORMAL TO NORMAL VOL ...
def from_lognormal_to_normal_vol(F, K, T, lognormal_vol, d = 0):
  
  premium = BS_LogNorm_price(F + d, K + d, T, lognormal_vol)
  
  foo = lambda vol : BS_norm_price(F, K, T, vol) - premium
  
  root = optimize.newton(foo, lognormal_vol * (F + d) )

  return root 
## ------------------------------------------------



# -> EVALUATE LOG-NORMAL VOL FROM SABR ...
def log_normal_vol(k, f, t, Alpha, Beta, Rho, Nu, shift):
  
  Fwd = f + shift
  AbsStrike = k + shift
  tol = 0.0000000001
  
  d_FK = ((Fwd * AbsStrike) ** (1 - Beta))
  d_LogF_K = np.log(Fwd / AbsStrike)
  
  SABRTerms = 1 + ((((1 - Beta)*(1-Beta) / 24.0) * Alpha*Alpha / d_FK) +  \
                    0.25 * Rho * Beta * Nu * Alpha / np.sqrt(d_FK) +  \
                    (2 - 3 * Rho*Rho) * Nu*Nu / 24.0) * t
  
  d_z = (Nu / Alpha) * np.sqrt(d_FK) * d_LogF_K


  if(np.abs(d_z) <= tol):
    Vol = (Alpha / (Fwd ** (1 - Beta))) * SABRTerms
    
  else:
    d_Denom = 1 + (1 - Beta) *(1 - Beta) / 24.0 * d_LogF_K *d_LogF_K \
              + (1 - Beta) *(1 - Beta)*(1 - Beta)*(1 - Beta) / 1920.0 * d_LogF_K *d_LogF_K*d_LogF_K*d_LogF_K

    d_NotATM = Alpha / np.sqrt(d_FK) / d_Denom

    d_X_Z = np.log((np.sqrt(1 - 2 * Rho * d_z + d_z * d_z) + d_z - Rho) / (1 - Rho))

    Vol = d_NotATM * d_z / d_X_Z * SABRTerms

  return Vol
## ------------------------------------------------



def calibrate_alpha_to_logN_ATM(f, t, atm_vol, beta, rho, nu, shift):
  
  func_obj = lambda alpha : log_normal_vol(f, f, t, alpha, beta, rho, nu, shift) - atm_vol

  alpha_0 = 0.2 * f /  ((f + shift ) ** beta)
  
  root = optimize.newton(func_obj, alpha_0)
  
  return root  
# ----------------------------------------------------------------------------  
  
  
# EVALUATE NORMAL VOL FROM SABR ...
def normal_vol(k, f, t, Alpha, beta, Rho, Nu, shift):
    # shift both strike and forward ...
    f += shift
    k += shift
    
    
    tol = 0.0000000001

    f_av = 0.5 * (f + k)
    gamma_1 = beta / (f_av )
    gamma_2 = -1.0 * beta * (1 - beta) / ((f_av ) * (f_av )) 
    zeta = (Nu / Alpha) * (f - k) / (f_av**beta)
    int_denom = (1 / (1 - beta)) * (f ** (1 - beta)  - k **(1 - beta) )
                                                                              
    x_cir = np.log((np.sqrt(1 - 2 * Rho * zeta + zeta *zeta) + zeta - Rho) / (1 - Rho))
    
    SABRTerms = 1.0 + ((2.0 * gamma_2 - gamma_1 *gamma_1) / 24.0 * Alpha * Alpha * (f_av ** (2.0 * beta ) ) + \
      (1.0 / 4.0) * Rho * Nu * Alpha * gamma_1 * (f_av ** beta) + \
      (2.0 - 3.0 * Rho * Rho) * Nu * Nu / 24.0) * t
                       
    
    auxPow = (f_av ** beta)
    auxLog = np.log(f_av )
    
    
    if np.abs( zeta ) <= tol:
      Vol = Alpha * (f ** beta) * SABRTerms
    else :
      Vol = Alpha * ((f - k) / int_denom) * (zeta / x_cir) * SABRTerms
    
    
    return Vol
## ------------------------------------------------
    
    
# CALIBRATE ALPHA TO ATM VOL ...        
def calibrate_alpha_to_ATM(f, t, atm_vol, beta, rho, nu, shift):
    # shift both strike and forward ...
    f += shift

    f_ = f ** (1 - beta)
    p = [
        - beta * (2 - beta) / (24 * f_ ** 2) * t * f ** beta,
        t * f ** beta * rho * beta * nu / (4 * f_),
        (1 + t * nu ** 2 * (2 - 3 * rho ** 2) / 24) * f ** beta,
        -atm_vol
    ]
    roots = np.roots(p)
    roots_real = np.extract(np.isreal(roots), np.real(roots))

    # Note: the double real roots case is not tested
    alpha_first_guess = atm_vol * f ** (-beta)
    i_min = np.argmin(np.abs(roots_real - alpha_first_guess))
    return roots_real[i_min]
## ------------------------------------------------



# DEFINITION OF SABR CONFIG ----------------------------------------
SABRConfig = namedtuple("SABRConfig", "calibrate_ATM use_tube tube_width use_vega_weights is_normal_vol")
  
   
# -> SABR CALIBRATION -----------------------------
class SABRCalibration:
  
    # CONSTRUCTOR ------------------------------------------------
    def __init__(self, forward, T, init_params, calibrate_params, config):

        self.forward = forward
        self.T = T
        self.params = init_params
        self.calibrate_params = calibrate_params
        self.config = config
        
        
        # Safety check ...
        if config.calibrate_ATM:
          self.calibrate_params[0] = False
          
        self.dst = 1e100

    # CALIBRATE ------------------------------------------------
    def calibrate(self, strikes, mkt_normal_vols):

        self.strikes = strikes + self.forward
        self.weights = np.ones(len(strikes))
        if self.config.use_vega_weights :
          if self.config.is_normal_vol:
            self.weights = np.array([BS_norm_vega(self.forward, K, self.T, sigma) \
                                     for K, sigma in zip(self.strikes, mkt_normal_vols)])
          else:
            self.weights = np.array([BS_LN_vega(self.forward, K, self.T, sigma) \
                                     for K, sigma in zip(self.strikes, mkt_normal_vols)])
        
          # Normalize total Weights ..
          total_weight = np.sum(self.weights) / len(self.strikes)
          self.weights /= total_weight
        
        # CHECK whether ATM is within the set of inputs if calibration is needed ...
        if (self.config.calibrate_ATM):
            idx = list(strikes).index(0)
            self.ATM_vol = mkt_normal_vols[idx]

        self.mkt_normal_vols = mkt_normal_vols

        
        lb = np.array([0.001, 0, -0.98, 0.001, 0])
        ub = np.array([0.1, 0.98, 0.98, 1.0, 0.1])
        
        # Set Bounds 
        boundaries = scp.optimize.Bounds(lb[self.calibrate_params], ub[self.calibrate_params])
        
        # PERFORM CALIBRATION
        res = minimize(self.evaluate_distance_to_market, self.params[self.calibrate_params], bounds = boundaries,
                       method='L-BFGS-B', options={'gtol': 1e-10, 'disp': False}, tol = 1e-9)
        
        # PERFORM CALIBRATION
        #res = minimize(self.evaluate_distance_to_market, self.params[self.calibrate_params], 
        #               method='BFGS', options={'gtol': 1e-10, 'disp': False}, tol = 1e-9)

        # return parameters ...
        return self.params, self.dst

    # OBJECTIVE FUNCTION ------------------------------------------------
    def evaluate_distance_to_market(self, params):

        # Complete the vector of params ...
        self.params[self.calibrate_params] = params

        # Calibrate ATM .. ?
        if self.config.calibrate_ATM:
          if self.config.is_normal_vol:
            self.params[0] = calibrate_alpha_to_ATM(self.forward, self.T, self.ATM_vol,
                                                    self.params[1], self.params[2],
                                                    self.params[3], self.params[4])
          else:
            self.params[0] = calibrate_alpha_to_logN_ATM(self.forward, self.T, self.ATM_vol,
                                      self.params[1], self.params[2],
                                      self.params[3], self.params[4])

        # Calculate model Volatilities ...
        if self.config.is_normal_vol:
          model_vols = [normal_vol(K, self.forward, self.T, self.params[0], self.params[1], \
                                   self.params[2], self.params[3], self.params[4]) for K in self.strikes]
        else:
          model_vols = [log_normal_vol(K, self.forward, self.T, self.params[0], self.params[1], \
                                       self.params[2], self.params[3], self.params[4]) for K in self.strikes]

        model_vols = np.array(model_vols)
        
        #print('SABR params', self.params)
        #print('Model Vols', model_vols)
        
        error = np.abs(model_vols - self.mkt_normal_vols) 
        if  self.config.use_tube:
          idx  = error < self.config.tube_width
          error[idx] = 0
          
        error *=  self.weights
        
        # dot product ...
        #dst = np.sqrt(np.dot(error, error) / len(model_vols))
        self.dst = np.dot(error, error) 
        dst = self.dst
        
        #print('Error:', dst)
        
        return dst
## ------------------------------------------------